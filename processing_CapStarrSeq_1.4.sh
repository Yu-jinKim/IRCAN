#!/bin/bash

set -e

usage="\n$(basename "$0") [-h] -d -f -f -f -f -g -c -- script to process fastq file from CapStarr-Seq\n\n

where:\n
\t  -h: show this help text\n
\t  -f: the fastq files to process (use -f several times for several files)\n
\t	-g: the genome file needed for extention of reads\n
\t	-d: directory where the result will be stored in\n
\t	-b: BED file of the genome for bedgraph\n
\t	-c: the capture regions file needed to compute capture efficiency\n\n

This script will declare names of the files generated and the steps which are running.\n
All the files generated by this script will be stored in a repertory located in the repertory of the main file.\n
The alignment procedure will use 3 threads per file."

if [ -z "$*" ]; then echo -e $usage; exit 0; fi

while getopts d::hf:g:c:r:b: option
do
	case "${option}"
	in
	d) DIRECTORY=${OPTARG};;
	f) FILES+=("$OPTARG");;
	b) BED=${OPTARG};;
	g) GENOME=${OPTARG};;
	c) CAPREGIONS=${OPTARG};;
	h) echo -e $usage
	   exit
	   ;;
	esac
done

if [[ -z $DIRECTORY ]]; then 
	dirname_directory="."
	basename_directory="capStarr_pipeline_1.4"
else
	dirname_directory=$(dirname $DIRECTORY)
	basename_directory=$(basename $DIRECTORY)
fi

if [ -d "$dirname_directory/$basename_directory" ]; then rm -Rf $dirname_directory/$basename_directory; fi
mkdir $dirname_directory/$basename_directory

for file in ${FILES[@]}; do
	
	(name_file=$(basename $file)
	name_file=${name_file%%.*}
	echo "Entered file name: "$name_file

	if [ -d "$dirname_directory/$basename_directory/$name_file" ]; then rm -Rf $dirname_directory/$basename_directory/$name_file; fi
	mkdir $dirname_directory/$basename_directory/$name_file

	directory=$directory
	echo "Directory:" $dirname_directory/$basename_directory/$name_file

	#### Step 1: align the reads ####

	bowtieOutput=$name_file.genomeAlignment

	echo -e "\nAlignment of reads in process ==> "$bowtieOutput"\n"

	gunzip -c $file | bowtie -v 2 -a -m 10 -t --threads 3 --best --tryhard $GENOME /dev/stdin > $dirname_directory/$basename_directory/$name_file/$bowtieOutput 2> $dirname_directory/$basename_directory/$name_file/bowtieLog

	nbAlignedReads=$(grep "reads with at least" $dirname_directory/$basename_directory/$name_file/bowtieLog | cut -d' ' -f9)
	numLinesFastq=$(grep "reads processed" $dirname_directory/$basename_directory/$name_file/bowtieLog | cut -d' ' -f4)

	#### Step 2: convert the result of the alignment to bed ####

	bowtie2bed_output=$bowtieOutput.sorted.bed

	echo -e "Conversion bowtie2bed in process ==> "$bowtie2bed_output"\n"

	sort -k1,1 $dirname_directory/$basename_directory/$name_file/$bowtieOutput \
	| /home/Share/dvanessen/bowtie2bed.pl -n stdin \
	| bedtools sort -i - \
	> $dirname_directory/$basename_directory/$name_file/$bowtie2bed_output

	#### Step 3: estimate frag length ####

	echo "Estimation of fragment length in process ==> "$name_file"\n"

	if [ -d "$dirname_directory/$basename_directory/$name_file/MACS_$name_file" ]; then rm -Rf $dirname_directory/$basename_directory/$name_file/MACS_$name_file; fi
	mkdir $dirname_directory/$basename_directory/$name_file/MACS_$name_file

	macs -t $dirname_directory/$basename_directory/$name_file/$bowtie2bed_output -g mm -n "$dirname_directory/$basename_directory/$name_file/MACS_$name_file/MACS_output" --keep-dup=all 2> "$dirname_directory/$basename_directory/$name_file/MACS_$name_file/MACS_log_$name_file"

	frag_length=$(grep "predicted fragment length" $dirname_directory/$basename_directory/$name_file/MACS_$name_file/MACS_log_$name_file \
	| cut -d ' ' -f14)

	echo -e "Estimated frag length (MACS) for "$bowtie2bed_output"==>" $frag_length "bp\n"
	if [[ -z $frag_length ]]; then echo "Couldn't get fragment length from MACS report, please check said report"; exit; fi

	#### Step 4: extend reads to frag length #### 

	extendedOutput=$bowtieOutput.sorted.ext.bed

	echo -e "Extention of reads to mean fragment length in process ==> "$extendedOutput"\n"

	awk -v size=$frag_length -v OFS='\t' '{if($6=="+"){cs=$2}else{cs=$3-size}$3=cs+size;if(cs<0){cs=0}$2=cs;print}' $dirname_directory/$basename_directory/$name_file/$bowtie2bed_output \
	| bedtools sort -i - \
	> $dirname_directory/$basename_directory/$name_file/$extendedOutput

	#### Step 5: Get number of aligning locations ####

	nbReads=$bowtieOutput.sorted.ext.uniqCloneName.bed

	echo -e "Processing the number of aligning locations, number of reads, clone names ==> "$nbReads"\n"

	awk -v OFS='\t' '{print $1, $2, $3, $4, $5, $6}' $dirname_directory/$basename_directory/$name_file/$extendedOutput \
	| /home/ykim/scripts/seq2clone_1.2.pl -f - \
	| sort -k1,1 -k2,2n -k6,6r \
	> $dirname_directory/$basename_directory/$name_file/$nbReads

	#### Step 6: Generate BedGraph ####

	bedGraph=$bowtieOutput.sorted.ext.bedGraph

	echo -e "Generating the bedGraph file ==> "$bedGraph"\n"

	/home/Share/dvanessen/bed2compressedBedGraph.pl -w $dirname_directory/$basename_directory/$name_file/$extendedOutput \
	> $dirname_directory/$basename_directory/$name_file/$bedGraph

	#### Step 7: Generate statistics ####

	statistics=$name_file.stats

	echo -e "Generating statistics file ==> "$statistics"\n"

	echo "Statistics summary for" $name_file > $dirname_directory/$basename_directory/$name_file/$statistics
	echo "" >> $dirname_directory/$basename_directory/$name_file/$statistics

	echo "Number of aligned reads:" $nbAlignedReads >> $dirname_directory/$basename_directory/$name_file/$statistics
	pour_alignedReads=$(awk -v a="$nbAlignedReads" -v b="$numLinesFastq" 'BEGIN{print a/b*100}')
	echo "% of aligned reads :" $pour_alignedReads >> $dirname_directory/$basename_directory/$name_file/$statistics

	nbClones=$(sort -k4,4 $dirname_directory/$basename_directory/$name_file/$nbReads \
	| awk '{if($4!=lastClone){print $0}lastClone=$4}' \
	| wc -l)
	echo "Number of clones:" $nbClones >> $dirname_directory/$basename_directory/$name_file/$statistics

	nbClonesCapRegions=$(sort -k4,4 $dirname_directory/$basename_directory/$name_file/$nbReads \
	| awk '{if($4!=lastClone){print $0}lastClone=$4}' \
	| intersectBed -a $dirname_directory/$basename_directory/$name_file/$nbReads -b $CAPREGIONS \
	| wc -l)
	echo "Number of clones in capture regions:" $nbClonesCapRegions >> $dirname_directory/$basename_directory/$name_file/$statistics
	pour_ClonesCapRegions=$(awk -v a="$nbClonesCapRegions" -v b="$nbClones" 'BEGIN{print a/b*100}')
	echo "% of clones in capture regions:" $pour_ClonesCapRegions >> $dirname_directory/$basename_directory/$name_file/$statistics

	echo "Estimated fragment length:" $frag_length "bp" >> $dirname_directory/$basename_directory/$name_file/$statistics) & 

done

wait

# get the array of seq2clone files
for file in ${FILES[@]}; do
	name_file=$(basename $file)
	name_file=${name_file%%.*}
	seq2clone_files+=$dirname_directory/$basename_directory/$name_file/$name_file.genomeAlignment.sorted.ext.uniqCloneName.bed" "
done

echo -e "\nMean frag length..\n"
# compute mean frag length within the master file
fragment_length=$(cat ${seq2clone_files[@]} \
| awk '{allSize+=$3-$2; i+=1}END{if(allSize/i-int(allSize/i)>=0.5){print int(allSize/i)+1}else{print int(allSize/i)}}')

echo -e "Labelling and Extension masterFile..\n"
# labelling clone names with the file from which it cames from
# extend to mean frag length (for future use of seq2clone)
awk -v OFS='\t' '{if(FILENAME!=oldFile){i++}oldFile=FILENAME; $4=$4 "." i; $NF=""; print $0}' ${seq2clone_files[@]} \
| sort -k1,1 -k2,2n \
| awk -v size=$fragment_length -v OFS='\t' '{if($6=="+"){cs=$2}else{cs=$3-size}$3=cs+size;if(cs<0){cs=0}$2=cs;print}' \
> $dirname_directory/$basename_directory/masterFile.labeled.ext

if [ -d "$dirname_directory/$basename_directory/extended_files" ]; then rm -Rf $dirname_directory/$basename_directory/extended_files; fi
mkdir $dirname_directory/$basename_directory/extended_files

echo -e "Extension files..\n"
# extend files to mean frag length
for file in ${seq2clone_files[@]}; do
	(name_file=$(basename $file)
	name_file=${name_file%%.*}
	awk -v size=$fragment_length -v OFS='\t' '{if($6=="+"){cs=$2}else{cs=$3-size}$3=cs+size;if(cs<0){cs=0}$2=cs;print}' $file \
	| sort -k1,1 -k2,2n \
	> $dirname_directory/$basename_directory/extended_files/$name_file.ext) &
done

wait

# get the array of file names
for file in ${FILES[@]}; do
	name_file=$(basename $file)
	name_file=${name_file%%.*}
	array+=$dirname_directory/$basename_directory/extended_files/$name_file.ext" "
done

echo -e "Seq2clone..\n"
# run seq2clone
awk -v OFS='\t' '{print $1, $2, $3, $4, $5, $6, $7, $8, $9}' $dirname_directory/$basename_directory/masterFile.labeled.ext \
| intersectBed -c -a - -b $CAPREGIONS \
| /home/ykim/scripts/seq2clone_1.2.pl -p -f /dev/stdin \
| sort -k1,1 -k2,2n \
> $dirname_directory/$basename_directory/masterFile.labeled.ext.seq2clone

echo -e "Intersect capReg..\n"
# get region type for capReg aligned data
intersectBed -wa -wb -a $dirname_directory/$basename_directory/masterFile.labeled.ext.seq2clone -b $CAPREGIONS \
| /home/ykim/scripts/addTypeRegion.py -m /dev/stdin \
> $dirname_directory/$basename_directory/masterFile.labeled.ext.seq2clone.aligned

echo -e "Not intersect capReg..\n"
# add NA for locations that do not align in capReg
intersectBed -v -a $dirname_directory/$basename_directory/masterFile.labeled.ext.seq2clone -b $CAPREGIONS \
| awk -v OFS='\t' '{print $0, "NA"}' \
> $dirname_directory/$basename_directory/masterFile.labeled.ext.seq2clone.notAligned

echo -e "Concatenation..\n"
# concatenate the aligned and not aligned data
cat $dirname_directory/$basename_directory/masterFile.labeled.ext.seq2clone.aligned $dirname_directory/$basename_directory/masterFile.labeled.ext.seq2clone.notAligned \
| sort -k1,1 -k2,2n \
> $dirname_directory/$basename_directory/justBeforeUnite

i=0

col_seqs=11
col_loc=10

echo -e "Add data..\n"
# for every file given, add data to corresponding locations in the masterFile
for file in ${array[@]}; do

	i=$((i+1))

	intersectBed -wb -f 1 -r -s -a $dirname_directory/$basename_directory/justBeforeUnite -b $file \
	| sort -k4,4 -k13,13 -u \
	| awk -v sumfield=16 -v OFS='\t' '{if($4!=name){if(NR>1){print name,total}total=0}name=$4;total+=$sumfield} END{print name,total}' \
	> $dirname_directory/$basename_directory/seqs_per_clone.tmp

	if (( $i==1 )); then
		intersectBed -wao -f 1 -r -s -a $dirname_directory/$basename_directory/justBeforeUnite -b $file \
		| cut -f1-9,18 \
		| awk -v OFS='\t' '{if($10=="."){$10="NA"}print}' \
		> $dirname_directory/$basename_directory/seqsLoc.tmp
	else
		intersectBed -wao -f 1 -r -s -a $dirname_directory/$basename_directory/justBeforeUnite -b $file \
		| cut -f18 \
		| awk -v OFS='\t' '{if($1=="."){$1="NA"}print}' \
		| paste $dirname_directory/$basename_directory/masterFile.labeled.ext.seq2clone.united - \
		> $dirname_directory/$basename_directory/seqsLoc.tmp
	fi

	awk -v OFS='\t' '(NR==FNR){data[$1]=$2} (NR>FNR){if($4 in data){print $0,data[$4]}else{print $0, "NA"}}' $dirname_directory/$basename_directory/seqs_per_clone.tmp $dirname_directory/$basename_directory/seqsLoc.tmp \
	| awk -v OFS='\t' -v col_seqs="$col_seqs" -v col_loc="$col_loc" '{ inter=$col_loc; $col_loc=$col_seqs; $col_seqs=inter;   print}' \
	> $dirname_directory/$basename_directory/masterFile.labeled.ext.seq2clone.united

	col_seqs=$((col_seqs+2))
	col_loc=$((col_loc+2))
done

echo -e "Annotate close regions..\n"
# Annotation of close regions where the ratio of nseqs/close > 10
/home/ykim/scripts/annotate_closeReg_1.0.py -f $dirname_directory/$basename_directory/masterFile.labeled.ext.seq2clone.united -n 4 \
| sort -k1,1 -k2,2nr -k6,6r \
| /home/ykim/scripts/annotate_closeReg_1.0.py -f - -n 4 -r 1 \
| sort -k1,1 -k2,2n -k6,6r \
> $dirname_directory/$basename_directory/masterFile.labeled.ext.seq2clone.united.closeReg

rm $dirname_directory/$basename_directory/seqs_per_clone.tmp
rm $dirname_directory/$basename_directory/seqsLoc.tmp
rm $dirname_directory/$basename_directory/justBeforeUnite

echo -e "Creating BED files with RGB code..\n"
# Creating of RGB code from ratio inp+inp/cDNA+cDNA for ambiguous locations
bedtools intersect -a $dirname_directory/$basename_directory/masterFile.labeled.ext.seq2clone.united.closeReg -b $BED \
| awk -v OFS='\t' '{ratio=($14+$18+1)/($10+$12+1); if(ratio<0.1){RGB="0,255,0"} \
else if(ratio>10){RGB="255,0,0"} \
else if(ratio>=0.1 && ratio<1){green=255/(ratio*10); if(green-int(green)>=0.5){green=int(green)+1}else{green=int(green)}; RGB="0,"green",0"} \
else if(ratio<=10 && ratio>1){red=255/ratio; if(red-int(red)>=0.5){red=int(red)+1}else{red=int(red)}; RGB=red",0,0"} \
else if(ratio==1){RGB="0,0,0"} \
$5=$14+$16+$10+$12; print $1, $2, $3, $4, $5, $6, $2, $3, RGB, ratio }' \
| awk -v OFS='\t' '{print $1, $2, $3, $4, $5, $6, $2, $3, $9}' \
> $dirname_directory/$basename_directory/masterFile.labeled.ext.seq2clone.united.ambRatio

# Creating of RGB code from ratio inp+inp/cDNA+cDNA for unambiguous locations
bedtools intersect -a $dirname_directory/$basename_directory/masterFile.labeled.ext.seq2clone.united.closeReg -b $BED \
| awk '$7==1' \
| awk -v OFS='\t' '{ratio=($14+$18+1)/($10+$12+1); if(ratio<0.1){RGB="0,255,0"} \
else if(ratio>10){RGB="255,0,0"} \
else if(ratio>=0.1 && ratio<1){green=255/(ratio*10); if(green-int(green)>=0.5){green=int(green)+1}else{green=int(green)}; RGB="0,"green",0"} \
else if(ratio<=10 && ratio>1){red=255/ratio; if(red-int(red)>=0.5){red=int(red)+1}else{red=int(red)}; RGB=red",0,0"} \
else if(ratio==1){RGB="0,0,0"} \
$5=$14+$16+$10+$12; print $1, $2, $3, $4, $5, $6, $2, $3, RGB, ratio }' \
| awk -v OFS='\t' '{print $1, $2, $3, $4, $5, $6, $2, $3, $9}' \
> $dirname_directory/$basename_directory/masterFile.labeled.ext.seq2clone.united.unambRatio

echo -e "Processing finished!\n"